<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Candle Wax Physics 3D</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #000;
      color: #fff;
      overflow: hidden;
      touch-action: none;
    }

    #gameContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    #header {
      padding: 12px;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
      z-index: 10;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
    }

    #header a {
      color: #fff;
      text-decoration: none;
      font-size: 24px;
    }

    #stats {
      display: flex;
      gap: 16px;
      font-size: 14px;
    }

    #stats div {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #stats .label {
      font-size: 10px;
      opacity: 0.7;
      text-transform: uppercase;
    }

    #stats .value {
      font-size: 18px;
      font-weight: bold;
      color: #ffd700;
    }

    #gameCanvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 10;
    }

    .btn {
      padding: 12px 24px;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 12px;
      color: #fff;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      backdrop-filter: blur(10px);
      transition: all 0.2s;
      touch-action: manipulation;
    }

    .btn:active {
      transform: scale(0.95);
      background: rgba(255, 255, 255, 0.2);
    }

    #instructions {
      position: absolute;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 16px 24px;
      border-radius: 12px;
      text-align: center;
      font-size: 14px;
      max-width: 90%;
      animation: fadeIn 0.5s;
      z-index: 10;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateX(-50%) translateY(-10px); }
      to { opacity: 1; transform: translateX(-50%) translateY(0); }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <div id="header">
      <a href="/">‚Üê</a>
      <div id="stats">
        <div>
          <div class="label">Wax</div>
          <div class="value" id="waxCount">0</div>
        </div>
        <div>
          <div class="label">Score</div>
          <div class="value" id="score">0</div>
        </div>
      </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="instructions">
      üïØÔ∏è Drag to tilt the world in 3D!<br>
      Collect wax in the bowls at the bottom
    </div>

    <div id="controls">
      <button class="btn" id="resetBtn">Reset</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
  <script>
    // Game state
    let waxCollected = 0;
    let score = 0;
    let waxDropTimer = 0;
    let instructionsTimeout;
    let tiltX = 0;
    let tiltZ = 0;

    // Three.js setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a15);
    scene.fog = new THREE.Fog(0x0a0a15, 10, 50);

    const canvas = document.getElementById('gameCanvas');
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 8, 12);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 1);
    scene.add(ambientLight);

    const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
    mainLight.position.set(5, 10, 5);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.width = 2048;
    mainLight.shadow.mapSize.height = 2048;
    scene.add(mainLight);

    // Warm candle glow
    const candleLight = new THREE.PointLight(0xff9933, 2, 20);
    candleLight.position.set(0, 4, 0);
    scene.add(candleLight);

    // Cannon.js physics world
    const world = new CANNON.World();
    world.gravity.set(0, -15, 0);
    world.broadphase = new CANNON.NaiveBroadphase();
    world.solver.iterations = 10;

    // Materials
    const waxMaterial = new CANNON.Material('wax');
    const groundMaterial = new CANNON.Material('ground');
    const waxGroundContact = new CANNON.ContactMaterial(waxMaterial, groundMaterial, {
      friction: 0.4,
      restitution: 0.3
    });
    world.addContactMaterial(waxGroundContact);

    // Create ground plane
    const groundShape = new CANNON.Plane();
    const groundBody = new CANNON.Body({ mass: 0, material: groundMaterial });
    groundBody.addShape(groundShape);
    groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
    groundBody.position.set(0, -3, 0);
    world.addBody(groundBody);

    const groundGeometry = new THREE.PlaneGeometry(30, 30);
    const groundMesh = new THREE.Mesh(
      groundGeometry,
      new THREE.MeshStandardMaterial({ color: 0x1a1a2e, roughness: 0.8 })
    );
    groundMesh.rotation.x = -Math.PI / 2;
    groundMesh.position.y = -3;
    groundMesh.receiveShadow = true;
    scene.add(groundMesh);

    // Create walls to contain wax
    const wallThickness = 1;
    const wallHeight = 10;
    const wallDistance = 10;

    function createWall(x, z, width, depth) {
      const shape = new CANNON.Box(new CANNON.Vec3(width / 2, wallHeight / 2, depth / 2));
      const body = new CANNON.Body({ mass: 0, material: groundMaterial });
      body.addShape(shape);
      body.position.set(x, wallHeight / 2 - 3, z);
      world.addBody(body);

      const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(width, wallHeight, depth),
        new THREE.MeshStandardMaterial({ color: 0x1a1a2e, transparent: true, opacity: 0.3 })
      );
      mesh.position.copy(body.position);
      scene.add(mesh);
      return { body, mesh };
    }

    createWall(0, -wallDistance, wallDistance * 2, wallThickness); // back
    createWall(0, wallDistance, wallDistance * 2, wallThickness); // front
    createWall(-wallDistance, 0, wallThickness, wallDistance * 2); // left
    createWall(wallDistance, 0, wallThickness, wallDistance * 2); // right

    // Create 3D candle
    const candleRadius = 0.8;
    const candleHeight = 4;
    const candleGeometry = new THREE.CylinderGeometry(candleRadius, candleRadius, candleHeight, 32);
    const candleMaterial = new THREE.MeshStandardMaterial({
      color: 0xf4e4c1,
      roughness: 0.7
    });
    const candleMesh = new THREE.Mesh(candleGeometry, candleMaterial);
    candleMesh.position.set(0, candleHeight / 2, 0);
    candleMesh.castShadow = true;
    scene.add(candleMesh);

    // Candle wick
    const wickGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8);
    const wickMesh = new THREE.Mesh(
      wickGeometry,
      new THREE.MeshStandardMaterial({ color: 0x2a2a2a })
    );
    wickMesh.position.set(0, candleHeight + 0.25, 0);
    scene.add(wickMesh);

    // Flame (animated sprite-like effect)
    const flameGeometry = new THREE.SphereGeometry(0.2, 8, 8);
    const flameMaterial = new THREE.MeshBasicMaterial({
      color: 0xffaa00,
      transparent: true,
      opacity: 0.8
    });
    const flameMesh = new THREE.Mesh(flameGeometry, flameMaterial);
    flameMesh.position.set(0, candleHeight + 0.6, 0);
    scene.add(flameMesh);

    // Flame glow
    const flameGlow = new THREE.PointLight(0xff6600, 1.5, 5);
    flameGlow.position.copy(flameMesh.position);
    scene.add(flameGlow);

    // Create collection bowls
    const bowls = [];
    const bowlPositions = [
      { x: -4, z: 0, score: 100, color: 0x4a9eff },
      { x: 0, z: 4, score: 200, color: 0xff4a9e },
      { x: 4, z: 0, score: 300, color: 0x9eff4a }
    ];

    bowlPositions.forEach(pos => {
      // Bowl physics (cylinder)
      const bowlRadius = 1.2;
      const bowlHeight = 0.5;
      const shape = new CANNON.Cylinder(bowlRadius, bowlRadius, bowlHeight, 16);
      const body = new CANNON.Body({ mass: 0, material: groundMaterial });
      body.addShape(shape);
      body.position.set(pos.x, -3 + bowlHeight / 2, pos.z);
      world.addBody(body);

      // Bowl visual
      const bowlGeometry = new THREE.CylinderGeometry(bowlRadius, bowlRadius * 0.8, bowlHeight, 16);
      const bowlMesh = new THREE.Mesh(
        bowlGeometry,
        new THREE.MeshStandardMaterial({
          color: pos.color,
          roughness: 0.5,
          metalness: 0.3,
          transparent: true,
          opacity: 0.6
        })
      );
      bowlMesh.position.copy(body.position);
      bowlMesh.receiveShadow = true;
      scene.add(bowlMesh);

      bowls.push({ body, mesh: bowlMesh, ...pos });
    });

    // Wax particles
    const waxParticles = [];

    function createWaxDrop() {
      const radius = 0.1 + Math.random() * 0.1;

      // Physics body
      const shape = new CANNON.Sphere(radius);
      const body = new CANNON.Body({
        mass: 0.5,
        material: waxMaterial,
        linearDamping: 0.3
      });
      body.addShape(shape);
      body.position.set(
        (Math.random() - 0.5) * 0.5,
        candleHeight + 0.3,
        (Math.random() - 0.5) * 0.5
      );
      world.addBody(body);

      // Visual mesh
      const geometry = new THREE.SphereGeometry(radius, 8, 8);
      const material = new THREE.MeshStandardMaterial({
        color: new THREE.Color().setHSL(0.11 + Math.random() * 0.05, 1, 0.6 + Math.random() * 0.1),
        roughness: 0.6,
        metalness: 0.2
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.castShadow = true;
      mesh.position.copy(body.position);
      scene.add(mesh);

      const particle = { body, mesh, collected: false, age: 0 };
      waxParticles.push(particle);

      // Remove old particles
      if (waxParticles.length > 300) {
        const removed = waxParticles.shift();
        world.removeBody(removed.body);
        scene.remove(removed.mesh);
      }

      return particle;
    }

    // Touch/Mouse controls for tilting
    let isDragging = false;
    let previousMouseX = 0;
    let previousMouseY = 0;

    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      previousMouseX = e.clientX;
      previousMouseY = e.clientY;
    });

    canvas.addEventListener('touchstart', (e) => {
      isDragging = true;
      previousMouseX = e.touches[0].clientX;
      previousMouseY = e.touches[0].clientY;
    });

    canvas.addEventListener('mouseup', () => isDragging = false);
    canvas.addEventListener('touchend', () => isDragging = false);
    canvas.addEventListener('mouseleave', () => isDragging = false);

    canvas.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const deltaX = e.clientX - previousMouseX;
        const deltaY = e.clientY - previousMouseY;
        tiltX = Math.max(-3, Math.min(3, deltaX * 0.05));
        tiltZ = Math.max(-3, Math.min(3, deltaY * 0.05));
        previousMouseX = e.clientX;
        previousMouseY = e.clientY;
        hideInstructions();
      }
    });

    canvas.addEventListener('touchmove', (e) => {
      if (isDragging && e.touches.length > 0) {
        const touch = e.touches[0];
        const deltaX = touch.clientX - previousMouseX;
        const deltaY = touch.clientY - previousMouseY;
        tiltX = Math.max(-3, Math.min(3, deltaX * 0.05));
        tiltZ = Math.max(-3, Math.min(3, deltaY * 0.05));
        previousMouseX = touch.clientX;
        previousMouseY = touch.clientY;
        hideInstructions();
      }
    });

    // Device orientation for mobile tilt
    if (window.DeviceOrientationEvent) {
      window.addEventListener('deviceorientation', (e) => {
        if (e.gamma !== null && e.beta !== null) {
          tiltX = Math.max(-3, Math.min(3, e.gamma * 0.05));
          tiltZ = Math.max(-3, Math.min(3, (e.beta - 45) * 0.05));
          hideInstructions();
        }
      });
    }

    function hideInstructions() {
      const instructions = document.getElementById('instructions');
      if (instructions && !instructionsTimeout) {
        instructionsTimeout = setTimeout(() => {
          instructions.style.display = 'none';
        }, 3000);
      }
    }

    function updateUI() {
      document.getElementById('waxCount').textContent = waxCollected;
      document.getElementById('score').textContent = score;
    }

    // Animation loop
    const timeStep = 1 / 60;
    function animate() {
      requestAnimationFrame(animate);

      // Update physics
      world.step(timeStep);

      // Apply tilt to gravity
      world.gravity.x = tiltX;
      world.gravity.z = -tiltZ;

      // Decay tilt
      tiltX *= 0.95;
      tiltZ *= 0.95;

      // Animate flame
      const time = Date.now() * 0.005;
      flameMesh.scale.y = 1 + Math.sin(time * 5) * 0.1;
      flameMesh.position.y = candleHeight + 0.6 + Math.sin(time * 3) * 0.05;
      flameGlow.position.copy(flameMesh.position);
      flameGlow.intensity = 1.5 + Math.sin(time * 4) * 0.3;

      // Drop wax
      waxDropTimer++;
      if (waxDropTimer > 8) {
        createWaxDrop();
        waxDropTimer = 0;
      }

      // Update wax particles
      waxParticles.forEach((particle, index) => {
        particle.mesh.position.copy(particle.body.position);
        particle.mesh.quaternion.copy(particle.body.quaternion);
        particle.age++;

        // Check if in bowl
        if (!particle.collected) {
          bowls.forEach(bowl => {
            const dx = particle.body.position.x - bowl.x;
            const dz = particle.body.position.z - bowl.z;
            const distance = Math.sqrt(dx * dx + dz * dz);

            if (distance < 1.2 && particle.body.position.y < -2) {
              particle.collected = true;
              waxCollected++;
              score += bowl.score;
              updateUI();

              // Change color
              particle.mesh.material.color.setHex(bowl.color);
              particle.mesh.material.emissive = new THREE.Color(bowl.color);
              particle.mesh.material.emissiveIntensity = 0.3;
            }
          });
        }
      });

      renderer.render(scene, camera);
    }

    animate();

    // Reset button
    document.getElementById('resetBtn').addEventListener('click', () => {
      waxParticles.forEach(particle => {
        world.removeBody(particle.body);
        scene.remove(particle.mesh);
      });
      waxParticles.length = 0;
      waxCollected = 0;
      score = 0;
      updateUI();

      const instructions = document.getElementById('instructions');
      instructions.style.display = 'block';
      clearTimeout(instructionsTimeout);
      instructionsTimeout = null;
    });

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Save score when leaving
    window.addEventListener('beforeunload', async () => {
      if (score > 0) {
        try {
          await fetch('/candle-wax/api/scores', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ score, waxCollected })
          });
        } catch (e) {
          console.error('Failed to save score:', e);
        }
      }
    });
  </script>
</body>
</html>
